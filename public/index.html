const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');
const { startWebServer, setDiscordClient, getStickyConfigs } = require('./dashboard-secure');

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

client.on('ready', async () => {
    console.log(`‚ú® ${client.user.tag} is online!`);
    
    // Start secure dashboard
    setDiscordClient(client);
    startWebServer();
    console.log('üîí Secure MEE6-style dashboard started!');
    
    // Register slash commands
    const commands = [
        {
            name: 'setup-sticky',
            description: 'üìå Setup an ephemeral sticky message for this channel (Admin only)',
            options: [
                {
                    name: 'title',
                    type: 3,
                    description: 'Title of the sticky message',
                    required: true
                },
                {
                    name: 'description',
                    type: 3,
                    description: 'Description text',
                    required: true
                },
                {
                    name: 'button-text',
                    type: 3,
                    description: 'Text on the button',
                    required: true
                },
                {
                    name: 'response',
                    type: 3,
                    description: 'Message to show when button is clicked',
                    required: false
                },
                {
                    name: 'gif-url',
                    type: 3,
                    description: 'GIF URL to show when button is clicked',
                    required: false
                },
                {
                    name: 'color',
                    type: 3,
                    description: 'Embed color (hex code like #FF69B4)',
                    required: false
                }
            ]
        },
        {
            name: 'remove-sticky',
            description: 'üóëÔ∏è Remove the sticky message from this channel (Admin only)'
        },
        {
            name: 'help',
            description: '‚ùì Show help information'
        }
    ];

    try {
        console.log('Registering slash commands...');
        await client.application.commands.set(commands);
        console.log('‚úÖ Slash commands registered successfully!');
    } catch (error) {
        console.error('Error registering commands:', error);
    }
});

// Handle interactions
client.on('interactionCreate', async (interaction) => {
    if (interaction.isChatInputCommand()) {
        if (interaction.commandName === 'setup-sticky') {
            await handleSetupSticky(interaction);
        } else if (interaction.commandName === 'remove-sticky') {
            await handleRemoveSticky(interaction);
        } else if (interaction.commandName === 'help') {
            await handleHelp(interaction);
        }
    } else if (interaction.isButton()) {
        await handleButton(interaction);
    }
});

// Send ephemeral sticky to users who send messages
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    const stickyConfigs = getStickyConfigs();
    const guildId = message.guild?.id;
    const channelId = message.channel.id;
    
    if (!guildId || !stickyConfigs[guildId] || !stickyConfigs[guildId][channelId]) return;
    
    const config = stickyConfigs[guildId][channelId];
    
    try {
        // Get GIF for sticky message
        let gifUrl = null;
        if (config.stickyGifs && config.stickyGifs.length > 0) {
            const gifs = config.stickyGifs;
            const mode = config.stickyMode || config.mode || 'random';
            
            if (mode === 'random') {
                gifUrl = gifs[Math.floor(Math.random() * gifs.length)];
            } else if (mode === 'cycle') {
                const index = config.stickyCurrentIndex || 0;
                gifUrl = gifs[index % gifs.length];
                config.stickyCurrentIndex = (index + 1) % gifs.length;
            } else {
                gifUrl = gifs[0];
            }
        } else if (config.gifUrl) {
            // Backwards compatibility
            gifUrl = config.gifUrl;
        } else if (config.gifs && config.gifs.length > 0) {
            gifUrl = config.gifs[0];
        }
        
        // Create the embed
        const embed = new EmbedBuilder()
            .setColor(config.color || '#FF69B4')
            .setTitle(config.title)
            .setDescription(config.description)
            .setFooter({ text: 'This message is only visible to you' })
            .setTimestamp();
        
        if (gifUrl) {
            embed.setImage(gifUrl);
        }
        
        // Create button
        const button = new ButtonBuilder()
            .setCustomId(`sticky_${guildId}_${channelId}_${message.author.id}`)
            .setLabel(config.buttonText)
            .setStyle(ButtonStyle.Primary);
        
        const row = new ActionRowBuilder().addComponents(button);
        
        // Send ephemeral message that only the user can see
        await message.reply({
            embeds: [embed],
            components: [row],
            flags: [4096] // EPHEMERAL flag
        }).catch(() => {
            // If reply fails, try sending in channel (fallback)
            message.channel.send({
                content: `<@${message.author.id}>`,
                embeds: [embed],
                components: [row]
            }).then(msg => {
                // Delete after 30 seconds
                setTimeout(() => msg.delete().catch(() => {}), 30000);
            });
        });
        
    } catch (error) {
        console.error('Error sending sticky:', error);
    }
});

async function handleSetupSticky(interaction) {
    // Check permissions
    if (!interaction.member.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return interaction.reply({ 
            content: '‚ùå You need "Manage Messages" permission to setup sticky messages!', 
            ephemeral: true 
        });
    }
    
    const title = interaction.options.getString('title');
    const description = interaction.options.getString('description');
    const buttonText = interaction.options.getString('button-text');
    const response = interaction.options.getString('response');
    const gifUrl = interaction.options.getString('gif-url');
    const color = interaction.options.getString('color') || '#FF69B4';
    
    if (!response && !gifUrl) {
        return interaction.reply({ 
            content: '‚ùå You must provide either a response message or GIF URL!', 
            ephemeral: true 
        });
    }
    
    // Get sticky configs from dashboard
    const stickyConfigs = getStickyConfigs();
    const guildId = interaction.guild.id;
    const channelId = interaction.channel.id;
    
    // Initialize guild config if needed
    if (!stickyConfigs[guildId]) {
        stickyConfigs[guildId] = {};
    }
    
    // Store configuration
    stickyConfigs[guildId][channelId] = {
        title,
        description,
        buttonText,
        responseMessage: response,
        color,
        stickyGifs: gifUrl ? [gifUrl] : [],
        stickyMode: 'single',
        buttonGifs: gifUrl ? [gifUrl] : [],
        buttonMode: 'single',
        // Backwards compatibility
        response,
        gifUrl,
        gifs: gifUrl ? [gifUrl] : [],
        mode: 'single'
    };
    
    await interaction.reply({ 
        content: `‚úÖ Ephemeral sticky message setup complete!\n\nNow when anyone sends a message in this channel, they'll see a private sticky message (only visible to them) with your button!\n\nüí° **Tip:** Use the web dashboard at https://supernova-z34z.onrender.com for advanced features like multiple GIFs and cycling modes!`, 
        ephemeral: true 
    });
}

async function handleRemoveSticky(interaction) {
    // Check permissions
    if (!interaction.member.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return interaction.reply({ 
            content: '‚ùå You need "Manage Messages" permission to remove sticky messages!', 
            ephemeral: true 
        });
    }
    
    const stickyConfigs = getStickyConfigs();
    const guildId = interaction.guild.id;
    const channelId = interaction.channel.id;
    
    if (!stickyConfigs[guildId] || !stickyConfigs[guildId][channelId]) {
        return interaction.reply({ 
            content: '‚ùå There is no sticky message configured for this channel!', 
            ephemeral: true 
        });
    }
    
    delete stickyConfigs[guildId][channelId];
    
    await interaction.reply({ 
        content: '‚úÖ Sticky message removed from this channel!', 
        ephemeral: true 
    });
}
    
    await interaction.reply({ 
        content: '‚úÖ Sticky message removed from this channel!', 
        ephemeral: true 
    });
}

async function handleButton(interaction) {
    // Extract guild and channel ID from button custom ID
    const parts = interaction.customId.split('_');
    const guildId = parts[1];
    const channelId = parts[2];
    
    const stickyConfigs = getStickyConfigs();
    
    if (!stickyConfigs[guildId] || !stickyConfigs[guildId][channelId]) {
        return interaction.reply({ 
            content: '‚ùå Sticky message configuration not found!', 
            flags: [4096] // EPHEMERAL
        });
    }
    
    const config = stickyConfigs[guildId][channelId];
    
    // Get GIF for button response
    let gifUrl = null;
    if (config.buttonGifs && config.buttonGifs.length > 0) {
        const gifs = config.buttonGifs;
        const mode = config.buttonMode || 'random';
        
        if (mode === 'random') {
            gifUrl = gifs[Math.floor(Math.random() * gifs.length)];
        } else if (mode === 'cycle') {
            const index = config.buttonCurrentIndex || 0;
            gifUrl = gifs[index % gifs.length];
            config.buttonCurrentIndex = (index + 1) % gifs.length;
        } else {
            gifUrl = gifs[0];
        }
    } else if (config.gifUrl) {
        // Backwards compatibility
        gifUrl = config.gifUrl;
    }
    
    // Build response
    let replyContent = {
        flags: [4096] // EPHEMERAL - only visible to the user
    };
    
    const responseMessage = config.responseMessage || config.response;
    
    if (gifUrl) {
        const embed = new EmbedBuilder()
            .setImage(gifUrl)
            .setColor(config.color || '#FF69B4');
        
        if (responseMessage) {
            embed.setDescription(responseMessage);
        }
        
        replyContent.embeds = [embed];
    } else if (responseMessage) {
        replyContent.content = responseMessage;
    } else {
        replyContent.content = '‚ú® Button clicked!';
    }
    
    await interaction.reply(replyContent);
}

async function handleHelp(interaction) {
    const embed = new EmbedBuilder()
        .setColor('#FF69B4')
        .setTitle('üìå Ephemeral Sticky Bot - Help')
        .setDescription('Create sticky messages that only appear to individual users!')
        .addFields(
            {
                name: 'üìå How It Works',
                value: 
                    '1. Admin sets up sticky message in a channel\n' +
                    '2. When anyone sends a message, they get a private sticky\n' +
                    '3. The sticky is only visible to them (ephemeral)\n' +
                    '4. They can click the button for a response\n' +
                    '5. Response is also private (only they see it)',
                inline: false
            },
            {
                name: '‚öôÔ∏è /setup-sticky',
                value: 
                    'Configure an ephemeral sticky for this channel\n\n' +
                    '**Required:**\n' +
                    '‚Ä¢ `title` - Title of sticky message\n' +
                    '‚Ä¢ `description` - Message content\n' +
                    '‚Ä¢ `button-text` - Text on button\n\n' +
                    '**Response (pick one):**\n' +
                    '‚Ä¢ `response` - Text message\n' +
                    '‚Ä¢ `gif-url` - GIF to show\n\n' +
                    '**Optional:**\n' +
                    '‚Ä¢ `color` - Hex color code',
                inline: false
            },
            {
                name: 'üóëÔ∏è /remove-sticky',
                value: 'Remove sticky message from this channel',
                inline: false
            },
            {
                name: 'üí° Example',
                value: 
                    '```/setup-sticky title:"Welcome!" description:"Thanks for chatting!" button-text:"Click Me" response:"Hello there!"```',
                inline: false
            },
            {
                name: '‚ú® Benefits',
                value: 
                    '‚Ä¢ No channel clutter - messages are private!\n' +
                    '‚Ä¢ Each user sees their own sticky\n' +
                    '‚Ä¢ Responses are also private\n' +
                    '‚Ä¢ Clean and organized',
                inline: false
            },
            {
                name: 'üîë Permissions',
                value: 'Only users with "Manage Messages" can setup/remove sticky messages',
                inline: false
            }
        )
        .setFooter({ text: 'Ephemeral Sticky Bot' })
        .setTimestamp();
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
}

client.login(process.env.DISCORD_TOKEN);
